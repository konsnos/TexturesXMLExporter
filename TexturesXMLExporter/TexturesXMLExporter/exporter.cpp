/*
* <author>Konstantinos Egkarchos</author>
* <contact>konsnosl@gmail.com</contact>
*/

#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <fstream>
#include <vector>
#include <iomanip>

#include "exporter.h"
#include "Statics.h"
#include "folder.h"

#include "boost\filesystem\path.hpp"
#include "boost\filesystem\operations.hpp"

#include <direct.h>
#include <time.h>

#include <exception>


using namespace std;
using namespace boost::filesystem;

unsigned long exporter::fileImg_count = 0;
unsigned long exporter::fileOther_count = 0;
unsigned long exporter::fileDif_count = 0;
unsigned long exporter::fileBmp_count = 0;
unsigned long exporter::fileNormal_count = 0;
unsigned long exporter::fileGloss_count = 0;
unsigned long exporter::fileHeight_count = 0;
unsigned long exporter::fileSpec_count = 0;
unsigned long exporter::fileRough_count = 0;
unsigned long exporter::fileMetal_count = 0;
unsigned long exporter::fileUnkn_count = 0;
unsigned long exporter::dir_count = 0;
unsigned long exporter::other_count = 0;
unsigned long exporter::err_count = 0;

int exporter::indents = 0;

/** Initializer variables and save to file the generated xml. */
exporter::exporter()
{
	fileImg_count = 0;
	fileOther_count = 0;
	fileDif_count = 0;
	fileBmp_count = 0;
	fileNormal_count = 0;
	fileGloss_count = 0;
	fileHeight_count = 0;
	fileSpec_count = 0;
	fileRough_count = 0;
	fileMetal_count = 0;
	fileUnkn_count = 0;
	dir_count = 0;
	other_count = 0;
	err_count = 0;

	ofstream myfile;
	myfile.open("textures.xml");

	if (generateTreeOrder())
	{
		myfile << generate_xml();
	}

	myfile.close();
}

bool exporter::generateTreeOrder()
{
	char currentPath[FILENAME_MAX];
	if (!_getcwd(currentPath, FILENAME_MAX))
	{
		cout << "Error: Could not retrieve current path. Exitting..." << endl;
		return false;
	}

	cout << "Current path is\n" << currentPath << endl << "\nTextures will be generated from this path." << endl << endl;

	path rootPath(currentPath);

	if (is_directory(rootPath))
	{
		rootFolder = new folder(rootPath);

		// Trim folders
		rootFolder->trimSingleMatFolders();
	}

	return true;
}

/** 
	Initialize string to write.
	Search for current directory for files recursively.
*/
const char* exporter::generate_xml()
{
	xmlToWrite = "<!-- Generated by TexturesXMLExporter, a tool built by Konstantinos Egkarchos (konsnosl@gmail.com) -->\n";
	
	{
		time_t rawtime;
		char buffer[50];

		time(&rawtime);

		strftime(buffer, 50, "%A %d %B %Y %X", localtime(&rawtime));

		xmlToWrite.append("<!-- This xml was exported at ");
		xmlToWrite.append(buffer);
		xmlToWrite.append(" -->\n");
		//delete date;
		xmlToWrite.append("<Texs>\n");
	}

	indents = 1;

	xmlToWrite.append(rootFolder->getXMLElement());

	cout << endl;
	cout << std::setfill('-') << std::setw(38) << " " << endl;
	cout << std::setfill(' ');
	printFormatted("| Images", fileImg_count);
	printFormatted("| Diffuse maps", fileDif_count);
	printFormatted("| Bump maps", fileBmp_count);
	printFormatted("| Normal maps", fileNormal_count);
	printFormatted("| Glossiness maps", fileGloss_count);
	printFormatted("| Height maps", fileHeight_count);
	printFormatted("| Specular maps", fileSpec_count);
	printFormatted("| Roughness maps", fileRough_count);
	printFormatted("| Metalness maps", fileMetal_count);
	printFormatted("| Unknown maps", fileUnkn_count);
	printFormatted("| Other files", fileOther_count);
	printFormatted("| Directories", dir_count);
	printFormatted("| Others", other_count);
	printFormatted("| Errors", err_count);
	cout << std::setfill('-') << std::setw(38) << " " << endl;
	cout << std::setfill(' ') << std::setw(0);

	xmlToWrite.append("</Texs>\n");
	return xmlToWrite.c_str();
}

void exporter::printFormatted(char* chars, int count) const
{
	cout << std::setw(26) << std::left << chars << std::right << std::setw(2) << "|" << std::setw(6) << count << std::setw(3) << "|"  << endl;
}


void exporter::addIndents(int indents, string &xmlToWrite, string &strToAppend)
{
	for (int i = 0; i < indents; i++)
		xmlToWrite.append("\t");

	xmlToWrite.append(strToAppend + "\n");
}

/** Removes all spaces from the string and returns the value. */
string removeSpaces(string str)
{
	str.erase(remove_if(str.begin(), str.end(), isspace));

	return str;
}

exporter::~exporter()
{
	//rootFolder->destroy();
}
